name: CD-STG

on:
  workflow_dispatch:

run-name: CD-STG-${{ github.run_number }}-${{ github.actor }}-${{ github.run_id }}

env:
  app_name: vista-alegre-servicepoint-ms-app
  version_image: latest
  secret_key_environment: staging
  stage_deploy: stg

jobs:
  # 1Ô∏è‚É£ Download and verify the artifact
  download-artifact:
    runs-on: ubuntu-latest
    environment: staging
    outputs:
      timestamp: ${{ steps.timestamp.outputs.timestamp }}
    steps:
      - name: Generate timestamp
        id: timestamp
        run: |
          TIMESTAMP=$(date +'%Y-%m-%d_%H:%M:%S')
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT
          echo "The workflow was generated with date: $TIMESTAMP"

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download Build Artifact
        id: download-artifact
        run: |
          echo "üîÑ Downloading artifact for version: ${{ env.version_image }} release"

          # Download the "app.tar.gz" artifact from the "${{ env.version_image }}" release
          gh release download ${{ env.version_image }} --pattern "app.tar.gz" --clobber

          # Check if the file was downloaded correctly
          if [[ ! -f app.tar.gz ]]; then
            echo "::error::The app.tar.gz file for the '${{ env.version_image }}' release could not be downloaded."
            exit 1
          fi

          # Check the size of the downloaded file
          file_size=$(stat -c%s app.tar.gz)
          if [[ "$file_size" -lt 10 ]]; then
            echo "::error::The downloaded file is too small (possibly empty or corrupt)."
            echo "Cotent file:"
            cat app.tar.gz
            exit 1
          fi

          # Check the type of downloaded file
          echo "Checking file type..."
          file_type=$(file app.tar.gz)
          echo "File type: $file_type"

          if [[ "$file_type" != *"gzip compressed data"* ]]; then
            echo "::error::The downloaded file is not a valid gzip file."
            echo "Content file:"
            cat app.tar.gz
            exit 1
          fi

          # Check the contents of the file
          echo "Checking file contents..."
          tar -tzf app.tar.gz > /dev/null
          if [[ $? -ne 0 ]]; then
            echo "::error::The downloaded file is not a valid tar.gz."
            exit 1
          fi

          echo "‚úÖ Artifact downloaded and verified successfully."
        env:
          GH_TOKEN: ${{ secrets.PERSONAL_TOKEN_RELEASE_ASSET }}

      - name: Check file size
        run: |
          ls -lh app.tar.gz
          echo "üìÑ File size: $(ls -lh app.tar.gz | awk '{print $5}')"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-artifact
          path: app.tar.gz

  # 2Ô∏è‚É£ Building and Pushing the Docker Image
  docker-build:
    runs-on: ubuntu-latest
    needs: download-artifact
    environment: staging
    # outputs:
    #   image_tag: ${{ steps.prepare.outputs.image_tag }} //output not found for envs secrets by github
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: app-artifact
          path: .

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ vars.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Prepare build context deploy to Docker Hub
        id: prepare
        run: |
          echo "üîß Preparing build context..."

          # Create and extract to build directory
          mkdir -p build-context
          tar -xzf app.tar.gz -C build-context --strip-components=0

          # Verify Dockerfile exists
          if [[ ! -f build-context/Dockerfile ]]; then
            echo "::error::Dockerfile not found in extracted archive"
            echo "Available files:"
            ls -la build-context/
            exit 1
          fi

          # Set build metadata
          BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          COMMIT_SHA=${{ github.sha }}
          IMAGE_TAG="${{ vars.DOCKER_HUB_USERNAME }}/${{ env.app_name }}-${{ env.stage_deploy }}:${{ env.version_image }}"

          echo "build_date=${BUILD_DATE}" >> $GITHUB_OUTPUT
          echo "commit_sha=${COMMIT_SHA}" >> $GITHUB_OUTPUT
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT

          echo "‚úÖ Build context prepared successfully"

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./build-context
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ steps.prepare.outputs.image_tag }}
          labels: |
            org.opencontainers.image.title=${{ env.app_name }}
            org.opencontainers.image.version=${{ env.version_image }}
            org.opencontainers.image.created=${{ steps.prepare.outputs.build_date }}
            org.opencontainers.image.revision=${{ steps.prepare.outputs.commit_sha }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            environment=${{ env.secret_key_environment }}
            stage=${{ env.stage_deploy }}
          build-args: |
            BUILD_DATE=${{ steps.prepare.outputs.build_date }}
            VERSION=${{ env.version_image }}
            COMMIT_SHA=${{ steps.prepare.outputs.commit_sha }}
            ENVIRONMENT=${{ env.secret_key_environment }}

            MICROSERVICE_NAME=${{ vars.MICROSERVICE_NAME }}
            APP_RUNNING_ENV=${{ vars.APP_RUNNING_ENV }}
            NODE_ENV=${{ vars.NODE_ENV }}
            NATS_SERVERS=${{ vars.NATS_SERVERS }}

            LOGGER_LEVEL=${{ vars.LOGGER_LEVEL }}
            LOGGER_ENABLED=${{ vars.LOGGER_ENABLED }}
            LOGGER_CLOUD=${{ vars.LOGGER_CLOUD }}
            TOKEN_LOGTAIL_LOGGER=${{ secrets.TOKEN_LOGTAIL_LOGGER }}

            DB_HOST_POSTGRES=${{ secrets.DB_HOST_POSTGRES }}
            DB_PORT_POSTGRES=${{ secrets.DB_PORT_POSTGRES }}
            DB_USERNAME_POSTGRES=${{ secrets.DB_USERNAME_POSTGRES }}
            DB_PASSWORD_POSTGRES=${{ secrets.DB_PASSWORD_POSTGRES }}
            DB_CONTAINER_NAME_POSTGRES=${{ secrets.DB_CONTAINER_NAME_POSTGRES }}
            DB_SYNCHRONIZE_POSTGRES=${{ secrets.DB_SYNCHRONIZE_POSTGRES }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: false
          sbom: false

      - name: Verify image on Docker Hub
        run: |
          echo "üîç Verifying deployed image..."
          # Stores the output variable in a shell variable for clarity and security
          IMAGE_TAG=${{ steps.prepare.outputs.image_tag }}

          # Check that the variable is not empty
          if [ -z "$IMAGE_TAG" ]; then
            echo "::error::The image_tag variable for the 'docker-build' job could not be fetched or is empty."
            exit 1
          fi

          echo "Inspecting the image: $IMAGE_TAG"
          docker buildx imagetools inspect "$IMAGE_TAG"
          echo "‚úÖ Image verification completed"
          echo "üì¶ Deployed image: $IMAGE_TAG"

  # 3Ô∏è‚É£ Deploy to service provider (gcp, aws, azure, etc)
  # deploy-to:
  #   runs-on: ubuntu-latest
  #   needs: docker-build
  #   environment: staging
  #   steps:
  #     - name: Deploy to Render cloud
  #       run: |
  #         echo "Deploying to Render.com"

  #         RENDER_SERVICE_ID=${{ secrets.RENDER_SERVICE_MS_STORE_STG_ID }}
  #         RENDER_API_KEY=${{ secrets.RENDER_API_KEY_STG }}

  #         # Realiza el despliegue en Render.com utilizando la API
  #         curl -s -X POST "https://api.render.com/v1/services/$RENDER_SERVICE_ID/deploys" \
  #           -H "Authorization: Bearer $RENDER_API_KEY" \
  #           -H "Accept: application/json" \
  #           -H "Content-Type: application/json" \
  #           -d '{
  #             "clearCache": "clear"
  #           }'

  #         echo "Deploy to Render.com initiated"
